.. _py_pi5_joystick:

2.1.2 Joystick
==============

Introduction
------------

In this project, We're going to learn how joystick works. We manipulate
the Joystick and display the results on the screen.

Components
------------------------------

In this project, we need the following components. 

.. image:: ../python_pi5/img/list/2.1.2_joystick_list.png

**ADS7830**

The ADS7830 is a single-supply, low-power, 8-bit data acquisition device that features a serial I2C interface and an 8-channel multiplexer. The following table is the pin definition diagram of ADS7830.

![](./img/ADS7830_Module.png)

**ADC**

An ADC is an electronic integrated circuit used to convert analog signals such as voltages to digital or
binary form consisting of 1s and 0s. The range of our ADC module is 8 bits, that means the resolution is
2^8=256, so that its range (at 3.3V) will be divided equally to 256 parts.
Any analog value can be mapped to one digital value using the resolution of the converter. So the more bits
the ADC has, the denser the partition of analog will be and the greater the precision of the resulting conversion.

![](./img/ADC_S.png)

Subsection 1: the analog in range of 0V-3.3/256 V corresponds to digital 0;

Subsection 2: the analog in range of 3.3 /256 V-2*3.3 /256V corresponds to digital 1;

…

The resultant analog signal will be divided accordingly.

**Joystick**

The basic idea of a joystick is to translate the movement of a stick into electronic information that a computer can process.

In order to communicate a full range of motion to the computer, a joystick needs to measure the stick’s position on two axes – the X-axis (left to right) and the Y-axis (up and down). Just as in basic geometry, the X-Y coordinates pinpoint the stick’s position exactly.

To determine the location of the stick, the joystick control system simply monitors the position of each shaft. The conventional analog joystick design does this with two potentiometers, or variable resistors.

The joystick also has a digital input that is actuated when the joystick is pressed down.

![](./img/image318.png)

When the data of joystick is read, there are some differents between axis: data of X and Y axis is analog, which need to use ADC0834 to convert the analog value to digital value. Data of Z axis is digital, so you can directly use the GPIO to read, or you can also use ADC to read.


Schematic Diagram
-----------------

When the data of joystick is read, there are some differents between
axis: data of X and Y axis is analog, which need to use ADS7830 Module to
convert the analog value to digital value. Data of Z axis is digital, so
you can directly use the GPIO to read, or you can also use ADC to read.

.. image:: ../python_pi5/img/schematic/2.1.9_joystick_schematic_1.png


.. image:: ../python_pi5/img/schematic/2.1.9_joystick_schematic_2.png

Connect
-----------------------

**Step 1:** Build the circuit.

.. image:: ../python_pi5/img/connect/2.1.2.png

**Step 2:** Go to the folder of the code.

.. raw:: html

   <run></run>

.. code-block::

    cd ~/super-starter-kit-for-raspberry-pi/python-pi5

**Step 3:** Run.

.. raw:: html

   <run></run>

.. code-block::

    sudo python3 2.1.2_Joystick_zero.py

After the code runs, turn the Joystick, then the corresponding values of
x, y, Btn are displayed on screen.

**Code**

.. note::

    You can **Modify/Reset/Copy/Run/Stop** the code below. But before that, you need to go to  source code path like ``super-starter-kit-for-raspberry-pi/python-pi5``. After modifying the code, you can run it directly to see the effect.


.. raw:: html

    <run></run>

.. code-block:: python

    #!/usr/bin/env python3

    import RPi.GPIO as GPIO
    import time
    from ADCDevice import *

    Z_Pin = 12      # define Z_Pin
    adc = ADCDevice() # Define an ADCDevice class object

    def setup():
        global adc
        if(adc.detectI2C(0x48)): # Detect the ads7830
            adc = ADS7830()
        else:
            print("No correct I2C address found, \n"
            "Please use command 'i2cdetect -y 1' to check the I2C address! \n"
            "Program Exit. \n");
            exit(-1)
        GPIO.setmode(GPIO.BOARD)        
        GPIO.setup(Z_Pin,GPIO.IN,GPIO.PUD_UP)   # set Z_Pin to pull-up mode
    def loop():
        while True:     
            val_Z = GPIO.input(Z_Pin)       # read digital value of axis Z
            val_Y = adc.analogRead(0)           # read analog value of axis X and Y
            val_X = adc.analogRead(1)
            print ('value_X: %d ,\tvlue_Y: %d ,\tvalue_Z: %d'%(val_X,val_Y,val_Z))
            time.sleep(0.01)

    def destroy():
        adc.close()
        GPIO.cleanup()
    
    if __name__ == '__main__':
        print ('Program is starting ... ') # Program entrance
        setup()
        try:
            loop()
        except KeyboardInterrupt: # Press ctrl-c to end the program.
            destroy()

**Phenomenon**
---------------
.. image:: ../img/phenomenon/212.jpg
    :width: 800
    :align: center
